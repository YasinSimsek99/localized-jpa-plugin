package com.localizedjpa.intellij

import com.intellij.openapi.project.DumbAware
import com.intellij.openapi.project.IndexNotReadyException
import com.intellij.psi.*
import com.intellij.psi.augment.PsiAugmentProvider
import com.intellij.psi.impl.light.LightFieldBuilder
import com.intellij.psi.impl.light.LightMethodBuilder
import com.intellij.psi.impl.light.LightModifierList
import com.intellij.psi.impl.source.PsiExtensibleClass
import com.intellij.psi.util.CachedValueProvider
import com.intellij.psi.util.CachedValuesManager

/**
 * PsiAugmentProvider for LocalizedJPA.
 *
 * This provider injects synthetic PSI elements (methods and fields) into classes
 * annotated with `@LocalizedEntity`. This enables IntelliJ IDEA to recognize
 * methods generated by the LocalizedJPA annotation processor at compile-time.
 *
 * ## Why This Is Needed
 * LocalizedJPA's annotation processor generates methods like `getName(Locale)`
 * and `setName(String, Locale)` at compile-time. Without this plugin, IntelliJ
 * would show "Cannot resolve method" errors since these methods don't exist
 * in the source code.
 *
 * ## Generated Elements
 * For each `@Localized` field:
 * - `T getFieldName(Locale locale)` - Localized getter
 * - `void setFieldName(T value, Locale locale)` - Localized setter
 *
 * For the class:
 * - `Map<String, XxxTranslation> translations` - Private field
 * - `Map getTranslations()` - Translations getter
 * - `void setTranslations(Map)` - Translations setter
 *
 * ## Dumb Mode Handling
 * This provider implements `DumbAware` to work during indexing. In dumb mode,
 * annotation resolution falls back to simple name matching instead of FQN lookup.
 *
 * @see com.intellij.psi.augment.PsiAugmentProvider
 */
class LocalizedJpaPsiAugmentProvider : PsiAugmentProvider(), DumbAware {

    companion object {
        private const val LOCALIZED_ENTITY_FQN = "com.localizedjpa.annotations.LocalizedEntity"
        private const val LOCALIZED_FQN = "com.localizedjpa.annotations.Localized"
    }

    /**
     * Provides augmented PSI elements for classes with @Localized fields.
     * 
     * This method is called by IntelliJ when resolving members of a class. The nameHint parameter
     * can be used for optimization - if provided, only augments matching that name need to be returned.
     * 
     * Note: @LocalizedEntity annotation is OPTIONAL. The plugin works with any class that has
     * @Localized fields, supporting both old (@LocalizedEntity + @Localized) and new (just @Localized) API.
     * 
     * @param element The PSI element to augment (we only handle PsiClass)
     * @param type The type of PSI element requested (PsiMethod or PsiField)
     * @param nameHint Optional name hint for optimization (e.g., "getName" when resolving that specific method)
     * @return List of augmented PSI elements
     */
    override fun <Psi : PsiElement> getAugments(
        element: PsiElement,
        type: Class<Psi>,
        nameHint: String?
    ): MutableList<Psi> {
        // Only handle PsiClass elements
        if (element !is PsiClass) {
            return mutableListOf()
        }

        // Only handle PsiMethod or PsiField requests
        if (type != PsiMethod::class.java && type != PsiField::class.java) {
            return mutableListOf()
        }

        // NEW LOGIC: Check if class has ANY @Localized fields
        // @LocalizedEntity is now OPTIONAL - not required for new API
        val hasLocalizedFields = getOwnFields(element).any { field ->
            hasAnnotation(field, LOCALIZED_FQN)
        }
        
        // Also check for @LocalizedEntity for backward compatibility
        val hasLocalizedEntityAnnotation = hasAnnotation(element, LOCALIZED_ENTITY_FQN)
        
        // If neither @Localized fields nor @LocalizedEntity annotation, skip
        if (!hasLocalizedFields && !hasLocalizedEntityAnnotation) {
            return mutableListOf()
        }

        // Use caching for performance
        // Using separate CachedValueProvider lambdas for methods vs fields ensures different cache entries
        return if (type == PsiMethod::class.java) {
            CachedValuesManager.getCachedValue(element) {
                val methods = generateLocalizedMethods(element).toMutableList()
                methods.addAll(generateTranslationsAccessors(element))
                CachedValueProvider.Result.create(methods, element)
            } as MutableList<Psi>
        } else {
            CachedValuesManager.getCachedValue(element) {
                val fields = mutableListOf<PsiField>()
                generateTranslationsField(element)?.let { fields.add(it) }
                CachedValueProvider.Result.create(fields, element)
            } as MutableList<Psi>
        }
    }

    /**
     * Gets the class's own fields WITHOUT triggering augmentation (prevents recursion).
     *
     * This method avoids infinite recursion by using [PsiExtensibleClass.ownFields]
     * which returns only the fields declared in the source file, not augmented ones.
     *
     * @param psiClass The class to get fields from
     * @return List of fields declared directly in the class
     */
    private fun getOwnFields(psiClass: PsiClass): List<PsiField> {
        // Use PsiExtensibleClass.ownFields to avoid recursion
        if (psiClass is PsiExtensibleClass) {
            return psiClass.ownFields
        }
        // Fallback: filter children directly (doesn't trigger augmentation)
        return psiClass.children.filterIsInstance<PsiField>()
    }

    /**
     * Generates getter/setter methods for each @Localized field.
     *
     * For a field `private String name;` annotated with `@Localized`, generates:
     * - `public String getName(Locale locale)`
     * - `public void setName(String value, Locale locale)`
     *
     * @param psiClass The class containing @Localized fields
     * @return List of generated light methods
     */
    private fun generateLocalizedMethods(psiClass: PsiClass): List<PsiMethod> {
        val methods = mutableListOf<PsiMethod>()
        val manager = psiClass.manager

        // IMPORTANT: Use getOwnFields() to avoid infinite recursion!
        for (field in getOwnFields(psiClass)) {
            if (!hasAnnotation(field, LOCALIZED_FQN)) {
                continue
            }

            val fieldName = field.name
            val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
            val fieldType = field.type

            // String getName(Locale locale)
            val getter = LightMethodBuilder(manager, "get$capitalizedName")
                .setMethodReturnType(fieldType)
                .setContainingClass(psiClass)
                .addParameter("locale", "java.util.Locale")
                .addModifier(PsiModifier.PUBLIC)
            methods.add(getter)

            // void setName(String value, Locale locale)
            val setter = LightMethodBuilder(manager, "set$capitalizedName")
                .setMethodReturnType(PsiTypes.voidType())
                .setContainingClass(psiClass)
                .addParameter("value", fieldType)
                .addParameter("locale", "java.util.Locale")
                .addModifier(PsiModifier.PUBLIC)
            methods.add(setter)
        }

        return methods
    }

    /**
     * Generates getTranslations() and setTranslations() methods.
     *
     * These methods provide access to the internal translations map that
     * the annotation processor generates for the entity.
     *
     * @param psiClass The @LocalizedEntity class
     * @return List containing getter and setter for translations
     */
    private fun generateTranslationsAccessors(psiClass: PsiClass): List<PsiMethod> {
        val methods = mutableListOf<PsiMethod>()
        val manager = psiClass.manager

        psiClass.name ?: return methods

        val factory = JavaPsiFacade.getElementFactory(psiClass.project)

        // Create Map type
        val mapType = factory.createTypeByFQClassName(
            "java.util.Map",
            psiClass.resolveScope
        )

        // Map<?, ?> getTranslations()
        val getter = LightMethodBuilder(manager, "getTranslations")
            .setMethodReturnType(mapType)
            .setContainingClass(psiClass)
            .addModifier(PsiModifier.PUBLIC)
        methods.add(getter)

        // void setTranslations(Map<?, ?> translations)
        val setter = LightMethodBuilder(manager, "setTranslations")
            .setMethodReturnType(PsiTypes.voidType())
            .setContainingClass(psiClass)
            .addParameter("translations", mapType)
            .addModifier(PsiModifier.PUBLIC)
        methods.add(setter)

        return methods
    }

    /**
     * Generates the translations field.
     *
     * Creates a private field: `private Map<String, XxxTranslation> translations;`
     *
     * @param psiClass The @LocalizedEntity class
     * @return The generated light field, or null if class has no name
     */
    private fun generateTranslationsField(psiClass: PsiClass): PsiField? {
        psiClass.name ?: return null

        val manager = psiClass.manager
        val factory = JavaPsiFacade.getElementFactory(psiClass.project)

        val mapType = factory.createTypeByFQClassName(
            "java.util.Map",
            psiClass.resolveScope
        )

        return LightFieldBuilder("translations", mapType, psiClass)
            .setModifierList(LightModifierList(manager).apply {
                addModifier(PsiModifier.PRIVATE)
            })
    }

    // ─────────────────────────────────────────────────────────────
    // Utility Methods
    // ─────────────────────────────────────────────────────────────

    /**
     * Checks if element has the specified annotation.
     *
     * This method handles two scenarios:
     * 1. **Normal mode**: Uses [PsiAnnotation.qualifiedName] to get the FQN
     * 2. **Dumb mode**: Falls back to simple name matching when index is not ready
     *
     * ## Why Simple Name Fallback?
     * During indexing (dumb mode), [PsiAnnotation.qualifiedName] throws
     * [IndexNotReadyException]. We catch this and fall back to comparing
     * just the annotation's simple name (e.g., "LocalizedEntity" instead of
     * "com.localizedjpa.annotations.LocalizedEntity").
     *
     * @param element The element to check for annotation
     * @param annotationFqn The fully qualified annotation name
     * @return true if the element has the annotation
     */
    private fun hasAnnotation(element: PsiModifierListOwner, annotationFqn: String): Boolean {
        val modifierList = element.modifierList ?: return false
        
        // Get the simple name from FQN (e.g., "LocalizedEntity" from "com.localizedjpa.annotations.LocalizedEntity")
        val simpleName = annotationFqn.substringAfterLast('.')
        
        for (annotation in modifierList.annotations) {
            try {
                // First try qualified name (works when index is ready)
                val qualifiedName = annotation.qualifiedName
                if (annotationFqn == qualifiedName) {
                    return true
                }
            } catch (e: IndexNotReadyException) {
                // In dumb mode, fall back to simple name matching
                val refName = annotation.nameReferenceElement?.referenceName
                if (simpleName == refName) {
                    return true
                }
            }
        }
        return false
    }
}
