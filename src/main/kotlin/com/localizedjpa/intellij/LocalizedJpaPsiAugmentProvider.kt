package com.localizedjpa.intellij

import com.intellij.openapi.project.DumbAware
import com.intellij.openapi.project.IndexNotReadyException
import com.intellij.psi.*
import com.intellij.psi.augment.PsiAugmentProvider
import com.intellij.psi.impl.light.LightFieldBuilder
import com.intellij.psi.impl.light.LightMethodBuilder
import com.intellij.psi.impl.light.LightModifierList
import com.intellij.psi.impl.source.PsiExtensibleClass
import com.intellij.psi.util.CachedValueProvider
import com.intellij.psi.util.CachedValuesManager

/**
 * PsiAugmentProvider for LocalizedJPA.
 *
 * This provider injects synthetic PSI elements (methods and fields) into classes
 * annotated with `@LocalizedEntity`. This enables IntelliJ IDEA to recognize
 * methods generated by the LocalizedJPA annotation processor at compile-time.
 *
 * ## Why This Is Needed
 * LocalizedJPA's annotation processor generates methods like `getName(Locale)`
 * and `setName(String, Locale)` at compile-time. Without this plugin, IntelliJ
 * would show "Cannot resolve method" errors since these methods don't exist
 * in the source code.
 *
 * ## Generated Elements
 * For each `@Localized` field:
 * - `T getFieldName(Locale locale)` - Localized getter
 * - `void setFieldName(T value, Locale locale)` - Localized setter
 *
 * For the class:
 * - `Map<String, XxxTranslation> translations` - Private field
 * - `Map getTranslations()` - Translations getter
 * - `void setTranslations(Map)` - Translations setter
 *
 * ## Dumb Mode Handling
 * This provider implements `DumbAware` to work during indexing. In dumb mode,
 * annotation resolution falls back to simple name matching instead of FQN lookup.
 *
 * @see com.intellij.psi.augment.PsiAugmentProvider
 */
class LocalizedJpaPsiAugmentProvider : PsiAugmentProvider(), DumbAware {

    companion object {
        private const val LOCALIZED_ENTITY_FQN = "com.localizedjpa.annotations.LocalizedEntity"
        private const val LOCALIZED_FQN = "com.localizedjpa.annotations.Localized"
    }

    /**
     * Provides augmented PSI elements for classes with @Localized fields.
     * 
     * This method is called by IntelliJ when resolving members of a class. The nameHint parameter
     * can be used for optimization - if provided, only augments matching that name need to be returned.
     * 
     * Note: @LocalizedEntity annotation is OPTIONAL. The plugin works with any class that has
     * @Localized fields, supporting both old (@LocalizedEntity + @Localized) and new (just @Localized) API.
     * 
     * @param element The PSI element to augment (we only handle PsiClass)
     * @param type The type of PSI element requested (PsiMethod or PsiField)
     * @param nameHint Optional name hint for optimization (e.g., "getName" when resolving that specific method)
     * @return List of augmented PSI elements
     */
    override fun <Psi : PsiElement> getAugments(
        element: PsiElement,
        type: Class<Psi>,
        nameHint: String?
    ): MutableList<Psi> {
        // Only handle PsiClass elements
        if (element !is PsiClass) {
            return mutableListOf()
        }

        // Only handle PsiMethod or PsiField requests
        if (type != PsiMethod::class.java && type != PsiField::class.java) {
            return mutableListOf()
        }

        // NEW LOGIC: Check if class has ANY @Localized fields
        // @LocalizedEntity is now OPTIONAL - not required for new API
        val hasLocalizedFields = getOwnFields(element).any { field ->
            hasAnnotation(field, LOCALIZED_FQN)
        }
        
        // Also check for @LocalizedEntity for backward compatibility
        val hasLocalizedEntityAnnotation = hasAnnotation(element, LOCALIZED_ENTITY_FQN)
        
        // If neither @Localized fields nor @LocalizedEntity annotation, skip
        if (!hasLocalizedFields && !hasLocalizedEntityAnnotation) {
            return mutableListOf()
        }

        // Use caching for performance
        // Using separate CachedValueProvider lambdas for methods vs fields ensures different cache entries
        return if (type == PsiMethod::class.java) {
            CachedValuesManager.getCachedValue(element) {
                val methods = generateLocalizedMethods(element).toMutableList()
                // Removed: translations accessors (getTranslations/setTranslations)
                // Users typically don't need these in autocomplete
                CachedValueProvider.Result.create(methods, element)
            } as MutableList<Psi>
        } else {
            // No synthetic fields needed
            CachedValuesManager.getCachedValue(element) {
                CachedValueProvider.Result.create(mutableListOf<PsiField>(), element)
            } as MutableList<Psi>
        }
    }

    /**
     * Gets the class's own fields WITHOUT triggering augmentation (prevents recursion).
     *
     * This method avoids infinite recursion by using [PsiExtensibleClass.ownFields]
     * which returns only the fields declared in the source file, not augmented ones.
     *
     * @param psiClass The class to get fields from
     * @return List of fields declared directly in the class
     */
    private fun getOwnFields(psiClass: PsiClass): List<PsiField> {
        // Use PsiExtensibleClass.ownFields to avoid recursion
        if (psiClass is PsiExtensibleClass) {
            return psiClass.ownFields
        }
        // Fallback: filter children directly (doesn't trigger augmentation)
        return psiClass.children.filterIsInstance<PsiField>()
    }

    /**
     * Generates getter/setter methods for each @Localized field.
     *
     * For a field `private String name;` annotated with `@Localized`, generates:
     * - `public String getName()` - Default getter (if not already defined)
     * - `public void setName(String value)` - Default setter (if not already defined)
     * - `public String getName(Locale locale)` - Locale-aware getter (if not already defined)
     * - `public void setName(String value, Locale locale)` - Locale-aware setter (if not already defined)
     *
     * NOTE: Methods are only generated if they don't already exist in the class.
     * This prevents conflicts when users define their own default getters/setters.
     *
     * @param psiClass The class containing @Localized fields
     * @return List of generated light methods
     */
    private fun generateLocalizedMethods(psiClass: PsiClass): List<PsiMethod> {
        val methods = mutableListOf<PsiMethod>()
        val manager = psiClass.manager

        // IMPORTANT: Use getOwnFields() to avoid infinite recursion!
        for (field in getOwnFields(psiClass)) {
            if (!hasAnnotation(field, LOCALIZED_FQN)) {
                continue
            }

            val fieldName = field.name
            val capitalizedName = fieldName.replaceFirstChar { it.uppercase() }
            val fieldType = field.type

            // Default getter: String getName()
            // Skip if ANY source (manual code, Lombok, other plugins) already provides it
            if (!hasMethodFromAnySource(psiClass, "get$capitalizedName", 0)) {
                val defaultGetter = LightMethodBuilder(manager, "get$capitalizedName")
                    .setMethodReturnType(fieldType)
                    .setContainingClass(psiClass)
                    .addModifier(PsiModifier.PUBLIC)
                methods.add(defaultGetter)
            }

            // Default setter: void setName(String value)
            // Skip if ANY source already provides it
            if (!hasMethodFromAnySource(psiClass, "set$capitalizedName", 1)) {
                val defaultSetter = LightMethodBuilder(manager, "set$capitalizedName")
                    .setMethodReturnType(PsiTypes.voidType())
                    .setContainingClass(psiClass)
                    .addParameter("value", fieldType)
                    .addModifier(PsiModifier.PUBLIC)
                methods.add(defaultSetter)
            }

            // Locale-aware getter: String getName(Locale locale)
            // These are LocalizedJPA-specific, unlikely to conflict with other plugins
            if (!hasMethodFromAnySource(psiClass, "get$capitalizedName", 1)) {
                val localeGetter = LightMethodBuilder(manager, "get$capitalizedName")
                    .setMethodReturnType(fieldType)
                    .setContainingClass(psiClass)
                    .addParameter("locale", "java.util.Locale")
                    .addModifier(PsiModifier.PUBLIC)
                methods.add(localeGetter)
            }

            // Locale-aware setter: void setName(String value, Locale locale)
            if (!hasMethodFromAnySource(psiClass, "set$capitalizedName", 2)) {
                val localeSetter = LightMethodBuilder(manager, "set$capitalizedName")
                    .setMethodReturnType(PsiTypes.voidType())
                    .setContainingClass(psiClass)
                    .addParameter("value", fieldType)
                    .addParameter("locale", "java.util.Locale")
                    .addModifier(PsiModifier.PUBLIC)
                methods.add(localeSetter)
            }
        }

        return methods
    }

    /**
     * Checks if a method with the given name and parameter count already exists from ANY source.
     * 
     * This includes:
     * - Methods defined directly in source code (user-defined)
     * - Methods that will be generated by OTHER plugins (detected via annotations)
     * 
     * This prevents generating duplicate methods that would cause "Ambiguous method call" errors.
     *
     * @param psiClass The class to check
     * @param methodName The method name to look for
     * @param paramCount The expected parameter count
     * @return true if a method with this signature already exists from any source
     */
    private fun hasMethodFromAnySource(psiClass: PsiClass, methodName: String, paramCount: Int): Boolean {
        // Check user-defined methods (ownMethods) - safe, no recursion
        val ownMethods = if (psiClass is PsiExtensibleClass) {
            psiClass.ownMethods
        } else {
            psiClass.children.filterIsInstance<PsiMethod>()
        }
        
        if (ownMethods.any { it.name == methodName && it.parameterList.parametersCount == paramCount }) {
            return true
        }
        
        // Check accessor-generating annotations ONLY for default methods:
        // - Default getter: getName() has 0 params
        // - Default setter: setName(String) has 1 param
        // Locale-aware methods (getName(Locale) with 1 param, setName(String,Locale) with 2 params) 
        // are NOT generated by accessor plugins like Lombok
        val isDefaultGetter = methodName.startsWith("get") && paramCount == 0
        val isDefaultSetter = methodName.startsWith("set") && paramCount == 1
        
        if (isDefaultGetter || isDefaultSetter) {
            val fieldName = methodName.removePrefix("get").removePrefix("set").replaceFirstChar { it.lowercase() }
            val field = getOwnFields(psiClass).find { it.name == fieldName }
            if (field != null && hasAccessorGeneratingAnnotation(field, psiClass, isDefaultGetter)) {
                return true
            }
        }
        
        return false
    }
    
    /**
     * Checks if a field or its containing class has annotations that will generate accessor methods.
     * 
     * This is a generic check that looks for common patterns used by accessor-generating plugins:
     * - Annotations with "Getter", "Setter", "Data", "Value", "Builder" in their name
     * - Annotations from known packages (lombok, etc.)
     * 
     * @param field The field to check
     * @param psiClass The containing class
     * @param isGetter True if checking for getter, false for setter
     * @return true if an accessor-generating annotation is found
     */
    private fun hasAccessorGeneratingAnnotation(field: PsiField, psiClass: PsiClass, isGetter: Boolean): Boolean {
        // Common annotation simple names that generate accessors
        val getterAnnotationNames = setOf("Getter", "Data", "Value")
        val setterAnnotationNames = setOf("Setter", "Data")
        val annotationNames = if (isGetter) getterAnnotationNames else setterAnnotationNames
        
        // Helper function to check if annotation matches
        fun matchesAnnotation(annotation: PsiAnnotation): Boolean {
            // Method 1: Check reference name
            val refName = annotation.nameReferenceElement?.referenceName
            if (refName != null && refName in annotationNames) {
                return true
            }
            
            // Method 2: Check qualified name
            try {
                val qualifiedName = annotation.qualifiedName
                if (qualifiedName != null) {
                    val simpleName = qualifiedName.substringAfterLast('.')
                    if (simpleName in annotationNames) {
                        return true
                    }
                }
            } catch (e: Exception) {
                // Ignore exceptions during qualified name resolution
            }
            
            // Method 3: Check annotation text (fallback)
            val text = annotation.text
            for (name in annotationNames) {
                if (text.contains("@$name") || text.contains("$name(")) {
                    return true
                }
            }
            
            return false
        }
        
        // Check field-level annotations
        for (annotation in field.annotations) {
            if (matchesAnnotation(annotation)) {
                return true
            }
        }
        
        // Check class-level annotations
        val classModifierList = psiClass.modifierList ?: return false
        for (annotation in classModifierList.annotations) {
            if (matchesAnnotation(annotation)) {
                return true
            }
        }
        
        return false
    }

    /**
     * Generates getTranslations() and setTranslations() methods.
     *
     * These methods provide access to the internal translations map that
     * the annotation processor generates for the entity.
     *
     * @param psiClass The @LocalizedEntity class
     * @return List containing getter and setter for translations
     */
    private fun generateTranslationsAccessors(psiClass: PsiClass): List<PsiMethod> {
        val methods = mutableListOf<PsiMethod>()
        val manager = psiClass.manager

        psiClass.name ?: return methods

        val factory = JavaPsiFacade.getElementFactory(psiClass.project)

        // Create Map type
        val mapType = factory.createTypeByFQClassName(
            "java.util.Map",
            psiClass.resolveScope
        )

        // Map<?, ?> getTranslations()
        val getter = LightMethodBuilder(manager, "getTranslations")
            .setMethodReturnType(mapType)
            .setContainingClass(psiClass)
            .addModifier(PsiModifier.PUBLIC)
        methods.add(getter)

        // void setTranslations(Map<?, ?> translations)
        val setter = LightMethodBuilder(manager, "setTranslations")
            .setMethodReturnType(PsiTypes.voidType())
            .setContainingClass(psiClass)
            .addParameter("translations", mapType)
            .addModifier(PsiModifier.PUBLIC)
        methods.add(setter)

        return methods
    }

    /**
     * Generates the translations field.
     *
     * Creates a private field: `private Map<String, XxxTranslation> translations;`
     *
     * @param psiClass The @LocalizedEntity class
     * @return The generated light field, or null if class has no name
     */
    private fun generateTranslationsField(psiClass: PsiClass): PsiField? {
        psiClass.name ?: return null

        val manager = psiClass.manager
        val factory = JavaPsiFacade.getElementFactory(psiClass.project)

        val mapType = factory.createTypeByFQClassName(
            "java.util.Map",
            psiClass.resolveScope
        )

        return LightFieldBuilder("translations", mapType, psiClass)
            .setModifierList(LightModifierList(manager).apply {
                addModifier(PsiModifier.PRIVATE)
            })
    }

    // ─────────────────────────────────────────────────────────────
    // Utility Methods
    // ─────────────────────────────────────────────────────────────

    /**
     * Checks if element has the specified annotation.
     *
     * This method handles two scenarios:
     * 1. **Normal mode**: Uses [PsiAnnotation.qualifiedName] to get the FQN
     * 2. **Dumb mode**: Falls back to simple name matching when index is not ready
     *
     * ## Why Simple Name Fallback?
     * During indexing (dumb mode), [PsiAnnotation.qualifiedName] throws
     * [IndexNotReadyException]. We catch this and fall back to comparing
     * just the annotation's simple name (e.g., "LocalizedEntity" instead of
     * "com.localizedjpa.annotations.LocalizedEntity").
     *
     * @param element The element to check for annotation
     * @param annotationFqn The fully qualified annotation name
     * @return true if the element has the annotation
     */
    private fun hasAnnotation(element: PsiModifierListOwner, annotationFqn: String): Boolean {
        val modifierList = element.modifierList ?: return false
        
        // Get the simple name from FQN (e.g., "LocalizedEntity" from "com.localizedjpa.annotations.LocalizedEntity")
        val simpleName = annotationFqn.substringAfterLast('.')
        
        for (annotation in modifierList.annotations) {
            try {
                // First try qualified name (works when index is ready)
                val qualifiedName = annotation.qualifiedName
                if (annotationFqn == qualifiedName) {
                    return true
                }
            } catch (e: IndexNotReadyException) {
                // In dumb mode, fall back to simple name matching
                val refName = annotation.nameReferenceElement?.referenceName
                if (simpleName == refName) {
                    return true
                }
            }
        }
        return false
    }
}
